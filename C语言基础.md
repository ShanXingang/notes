# C语言基础

## 数据

四种数据类型：<font style="color:red">**整型**</font>、<font style="color:red">**浮点型**</font>、<font style="color:red">**指针**</font>、<font style="color:red">**结构体**</font>

<font style="color:orange">q：为什么要设计不同的数据类型？</font>

<font style="color:green">a：我们需要数据进行存储和运算，如果各种数据都用相同的方法进行存储，很可能造成极大的空间浪费。比如说一个比较小的整数，用1个字节就能存储，你不加区分的用最大的8个字节去存储，那就浪费了7倍资源。所以对数据类型极性区分，是为了在有限资源中进行高效的存储和运算。</font>



### 基本数据类型

#### 整型

基础的有以下四种类型：

+ 字符 char
+ 短整型 short 或者写成 short int
+ 整型 int
+ 长整型 long 或者写成 long int

但是对于这四种类型，又有 singed和unsinged两种修饰，前者表示有符号可以表示负数，后者没符号表示非负数。

范围如下：

| 类型                                         | 字节            | 位数 | 范围                     |
| -------------------------------------------- | --------------- | ---- | ------------------------ |
| char                                         | 1个字节         | 8    | 0 ~ 127                  |
| singed char                                  | 1个字节         | 8    | -127 ~ 127               |
| unsinged char                                | 1个字节         | 8    | 0 ~ 255                  |
| short                                        | 2个字节         | 16   | -32767 ~ 32767           |
| unsinged short                               | 2个字节         | 16   | 0 ~ 65535                |
| int                                          | 一般4个字节     | 32   | -2147483647 ~ 2147483647 |
| unsigned int                                 | 一般4个字节     | 32   | 0 ~ 4294967295           |
| long                                         | 一般也是4个字节 | 32   | -2147483647 ~ 2147483647 |
| unsinged long                                | 一般也是4个字节 | 32   | 0 ~ 4294967295           |
| <font style="color:red">**long long**</font> | 8个字节         | 64   | -2^64+1 ~ 2^64-1         |

表示方法：

十进制的跟以前一样	24

八进制的在前面加0	024

十六进制的前面加0x	0x24

**注：表示范围跟编译器有关，int有时可以是16位，也可以是32位。但是有一个原则：short最多跟int一样长，long最少跟int一样长**

#### 浮点类型

存储小数用的。有三种类型：float、double、long double。

浮点数的存储，以32位的float为例：

任何浮点数都可以转换成  $(-1)^S * (1+\frac{M}{2^{23}}) * 2^{E-127}$形式，所以存储的时候需要这三个数字属性。

![浮点数存储](img/浮点数存储.png)

第一段，S表示符号，正负。1个bit。0表示正数，1表示负数。

第二段，E表示指数，8个bit。之所以要-127，是因为考虑到指数可以是负数，所以取一半表示负数。

第三段，M表示小数部分，23个bit。

| 类型        | 字节 | 位数 |
| ----------- | ---- | ---- |
| float       | 4    | 32   |
| double      | 8    | 64   |
| long double | 16   | 128  |

**现在的问题就是怎么把小数部分转换成二进制的M**

整数可以写成 $a*2^0 + b*2^1 + ... c*2^n$ 这种形式（a、b、c  in {0, 1}），整数部分可以通过除以2取余数来获取二进制，

小数可以写成 $a*\frac{1}{2} + b*\frac{1}{2^2} + c*\frac{1}{2^n}$ 这种形式（a、b、c  in {0, 1}），小数部分则可以通过乘以2的形式来获取二进制。

举个例子 3.875

整数部分3=2+1，换成二进制是11

小数部分0.875=$\frac{1}{2} + \frac{1}{4} + \frac{1}{8}$ 换成二进制是0.111

所以整个数字二进制是11.111 也即是3.875=1.<font style="color:red">1111</font> * 2^1 

因此，符号S=0，指数E=1+127=128，位数M1111后面补充0

总的来说浮点数3.875在计算机内存储的形式是 **<font style="color:green">0</font><font style="color:orange">10000000</font><font style="color:red">11110000000000000000000</font>**

#### 指针

本质是一个变量，只不过这个变量是指向其他变量的内存地址。

定义格式是 datatype *name;  需要在变量前面加星号。

<font style="color:orange">q：指针是内存地址，那么为什么指针还要分这么多类型？</font>

<font style="color:green">a：为了方便通过内存地址取值。不同类型的数据有不同的存储方式，如int就是4个字节，char就是1个字节。指针表示变量的内存地址，实质上是表示这个变量地址的初始位置。假如说现在有一个指针 *p 表示地址 0X0001，我现在要读取p值地址的数据，需要读取几个字节内存？如果指针是int类型，那就读取4个字节0X0001-0X0004；如果指针是char类型，那就读取一个字节就行。</font>

赋值的时候，需要给指针赋值一个地址，否则是错误的。地址的话，在变量前面加一个&符号即可。

**定义指针时必须带*号，给指针赋值时可以不带\*号，但是赋值必须是地址**

```c
int a = 3;
int *p1; // 定义时必须*
p1 = &a; // 赋值时p1可以不带*，但是内容必须是地址
```

**指针可以修改值，也可以获取值**

```c
int a = 3;
int *p1 = &a;
printf("%d %d", a, *p1); // 打印都是3，p表示指针，*p指的是指针指向的内存地址的值
*p1 = 4;
printf("%d %d", a, *p1); // 打印的都是4
```

<font style="color:orange">q：那么指针是占几个字节呢？</font>

<font style="color:green">a：指针只是表示地址，占几个字节跟指针的类型没有关系，跟语言也没有关系，只跟系统有关。一般来说32位系统中指针占4个字节，64位系统中指针占8个字节。可以写代码测试下，定义一个*p，printf("%d", sizeof(p))，但是会发现有时候在64位系统上打印出来的也是4个字节，那是因为系统要兼容32位的程序，可以自己手动调一下设置。</font>

**指针的运算**

举个例子说明，int a = 3; int *p = &a; 假设 *p 最开始指向的是地址 0X0001，那么 p++后，它指向的内容会向后加4个字节长度，对应int的长度，因为指针每次要完整读取一个数据才行。假如是short，那么p++会加2个字节；long则加4个。以此类推。

**p *p &p的区别**

```c
int a = 3;
int *p;
p = &a; // p存储a的地址  printf(p) 打印p存储的a的地址
*p = 4; // p指向的地址的值修改为4  printf(*p) 打印p指向的地址的值
&p; // 表示指针P的地址 printf(&p) 打印p的地址
```

**字符串常量**

本质上是一个指针，指向一系列字符的初始位置，字符的结尾是NUL，也就是'\0'。即使是空字符也包含结尾符号。

下面例子中，都是字符数组，但是本质上不一样。arr 只有5个元素，而message有6个元素，最后一个是'\0'。

```c
char[] arr = {'h', 'e', 'l', 'l', 'o'};
char* message = "hello";
```



### 其他数据

#### **字面量**

固定值的一种表示方法，就是已经确定的值。

+ 可以是整型  22， 23L
+ 可以是浮点型 22.2，33.3F
+ 可以是字符型 'a'、'b'
+ 可以是字符串型 "Hello world"

#### **枚举类型**

先举个例子

```c
// 定义一个枚举类型 Day
enum Day{
    MON = 1,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
};
// 声明一个枚举类型Day的变量
enum Day day;
// 定义这个变量的数值
day = WED;
// 打印测试 结果打印3
printf("%d", day); 
```

枚举类型本质上与 define是一样的，都是用一些有意义的字符串表示某些数字。但是如果全部用define表示，那么会显得宏定义比较杂乱。

<font style="color:red">**数值关系：**</font>如果最开始的枚举数没有给定一个值，那么默认从0开始；后面一个数的值是前面一个数+1。



### 声明

#### **变量声明**

int a; 	int a = 5;

#### **数组声明**

int values[20];	int values[5] = {1, 2, 3, 4, 5};	int values[5] = {1, 2, 3};

最后一个，元素不足5个，补充0。

#### **指针声明**

int *a;	char *message = "hello";

<font style="color:red">int *a, b, c； 其中只有a是指针，b、c是int类型数据变量。</font>

#### **隐式声明**<font style="color:red">（不推荐）</font>

变量不声明具体的类型，默认是整型。

函数不声明具体的返回类型，默认是void。

#### **typedef、define用法**

共同点：他们都是一种宏替代的方法，都是为了程序修改起来更方便而存在的。都是用新的名称替代原来的函数或者常量。

不同点：typedef可以操作指针，define则不行。并且define是在编译期间就进行替换，不会有类型的检查；typedef是在代码运行期间进行替换的，如果出问题会报错。

应用场景：在简单的常量替换和函数操作时用define，在新的类型替换时用typedef。

#### **const 关键词**

const修饰不可修改的变量。它的本质还是一个变量。

<font style="color:red">const最大的问题是与指针等联合使用的区分</font>

方法：谁离const近，谁就不能被修改。

```C
// 下面两种写法是等价的，因为这个不是指针变量，只表示数值。
const int a = 5;
int const a = 5;
// 当涉及指针时候需要注意
int *p; // 表示一个普通的指向整型的指针。
int* const p; // 表示一个指向整型的指针，不可以修改指针的值，但是能修改指针指向的值。
int const *p; // 表示一个指向整型的指针，可以修改指针的值，但是不能修改指针指向的值。
const int* p; // 表示一个指向整型的指针，可以修改指针的值，但是不能修改指针指向的值。
int const * const p; // 表示一个指向整型的指针，不可以修改指针的值，不能修改指针指向的值。
```



### 数据类型转换

类型转换，**只是临时性的**，数据本身的存储方式并没有改变。只是使用的时候，显示方式改变了。

#### 自动类型转换

程序认为数据类型需要转换，偷偷地进行了，不需要程序员干预。

这种情况一般发生在多种数据类型在混合计算中，或者赋值的情况当中。

自动转换的规则：

![自动类型转换](img/自动类型转换.png)

+ 一般而言，当精度小的和精度大的混合运算时，需全部转换成精度大的进行计算。如int和long计算，需要转换成long。
+ 对于所有的浮点数，都转换成double计算。
+ 对于short和char，都需要先转换成int再计算。

#### 强制类型转换

（新类型名称）表达式;



### 作用域

作用域表示变量或者表达式的有效范围。**本质是变量和表达式在内存中存在的生命周期。**

#### <font style="color:red">代码块作用域（局部变量）</font>

{}中间的代码，并且{}可以嵌套。在{}中定义的变量，只能在当前{}中有效。

嵌套的{}内层和外层有区别，外层的变量可以在内层用，内层的变量不能在外层中使用。同时如果内层外层都定义了一个相同名称的变量，在使用时，操作代码在哪一层就使用哪一层的变量数值。

#### <font style="color:red">文件作用域（全局变量）</font>

这个文件作用域中的文件，只的是.c文件。也就是在这个.c文件中都有用。

在代码块之外声明的变量都具有文件作用域。

#### 原型作用域（函数原型）

这个是针对函数原型而言的。在代码使用上基本没什么需要关注的。

函数原型实际上是函数声明的一种。比如说，main函数里需要调用func1函数，但是func1函数是写在main函数后面的，程序在main中调用func1会发生错误，那么解决这个问题有两种方法，一种是将func1函数写在main前面，一种则是在.c文件的顶部区域对函数进行声明，如下：

```c
void func(int a, int b); // 函数声明
void func2(int); // 函数原型可以不带参数

int main(){
    return 0;
}

void func1(int a, int h){} // 函数定义和函数声明里面的形参可以不一致

void func2(int a){}
```



### 链接属性

不少书本和博客关于这方面的内容，一上来就是外部链接、内部链接和none这些东西，并没有讲外部和内部都有哪些作用，虽然内容简单，但是初看起来还是让人一头雾水。C项目是以工程为基准的，一个C项目里面可能有好多个.c文件，如a.c文件，b.c文件等，如果a.c文件中的变量或者函数能在b.c文件中直接使用，那么这些变量或者函数是外部链接；否则是内部链接或者是none。

+ 默认情况下全局变量是external，代码块内的变量默认是none。
+ static修饰则是internal。extern修饰则是external。

<font style="color:orange">q：为什么需要全局变量？</font>

<font style="color:green">a：这个涉及到C项目的编译内容。C项目包含多个.c文件，首先需要将.c文件进行预处理，然后编译成汇编的.s文件，然后将.s文件转换成二进制的机器语言.o文件，一个.c文件对应一个.o文件。然后需要将多个.o文件和依赖库文件进行链接，最终生成.exe文件。那么在链接过程中，多个.c文件中可能有一些变量或者函数是重名了的，那么为了进行区分，a.c文件中的int h，与b.c文件中的int h，是同一个变量还是只在各自的文件中起作用，这个需要界定清楚，所以需要给定一个链接属性。同时可以看出，函数内的局部变量和形参，都是另外开辟一个栈内存存储变量的，不存在混用的情景，因此这些变量没有链接属性。</font>



### 数据的存储

数据都是以二进制形式存放在计算机中的。

#### 原码、反码和补码

**有符号** 最前一位，如果是0表示正数，如果是1表示负数。

**无符号** 没有符号位，全部是非负数。

相同位数的有符号和无符号数的表示的范围不一样。

当有符号和无符号的数据在同一个表达式中，**都会先转换成无符号数。**

**原码** 数字的原本二进制表示方法

比如1，00000001；比如-1，10000001。

**反码** 正数的反码就是原码保持不变，负数的反码是原码的符号位保持不变，其他位都取反。

比如 1，原码是 00000001，是正数反码跟原码一样，所以反码也是 00000001。

比如-2，原码是 10000010，是负数所以需要进行处理，最终反码是 11111101。

<font style="color:red">**反码的存在是为了解决计算机中减法问题**</font>

在计算机最底层，只支持加法运算，那么减法怎么处理？加上一个负数就算是减法。但是对负数的原码做加法运算，会出现问题，导致结果不对，所以设置一个反码来解决减法问题。

两个正数相加，没有问题；两个负数相加，可以看作是两个正数相加，然后把结果的符号位强制换成1就行。

关键的问题是正数和负数相加。比如1+(-2)：

（1反码）00000001 + （-2反码）11111101 = （结果反码）11111110

把结果的反码再取一下反码就得到结果 100000001，也就是-1。能成功解决问题。

可以类比时针向前转一圈跟向后转一圈效果一样，反码就相当于转了一圈。

**补码（原码和补码相加刚好能溢出）**

<font style="color:red">解决0和-0的问题，同时补码更有利于计算</font>

正数和0的补码和原码相同。负数的补码是反码+1。

比如 1，原码是 00000001，是正数反码跟原码一样，所以反码也是 00000001，补码也是 00000001。

比如-1，原码是 10000001，是负数所以需要进行处理，最终反码是 11111110，在此基础上补码是 11111111。

所以按照补码来讲，1-1=1+(-1)：

（1补码）00000001 + （-1补码）11111111 = （结果补码溢出）00000000

结果补码求原码，0的补码是本身，得到 00000000，结果是0。

**总结**

+ 原码是初始的二进制
+ 反码是解决减法问题的
+ 补码是解决0和-0问题的，目前计算机上数据都是用补码进行存储的。



## 语句、操作符和表达式

### 语句

#### 空语句

本身只有一个分号。不执行任何任务。基本上很少用。

应用场景：空循环体。



#### 表达式语句

能够执行一些操作的语句。分为两种，一种是单纯的表达式语句，另一种是赋值语句。

如 y + 3; 就是计算y+3的结果，但是没有保存结果，计算完成后就直接抛弃了。

如 x = y + 3;是表达式语句，也是赋值语句，将y+3的结果保存在x中。



#### if语句

跟java里的情况差不多。可以多重嵌套；多个情况用else if区分。

```c
if(判断条件){
	// 任务1
}else if(判断条件2){
	// 任务2
}else{ // 其他情况
	// 任务3
	// 可嵌套，任务只有一行的话，可以省略{}
	if(判断条件3)
		// 任务4，一行
	else
		// 任务5，一行
}
```

**短路和断路**

if判断的是复合语句，如果前面的部分就已经能确定复合语句的真假，那么就不会再继续执行后面的语句。

```c
int i = 1;
int j = 2;
if (i++ == 2 && ++j == 3) {// 由于i++==2是假的，所以后面的代码++j==3不会执行
    printf("%d %d\n", i, j);
}
else {
    printf("%d %d\n", i, j);
}

i = 1;
j = 2;
if (++j == 3 || i++ == 2) {// ++j==3是真，能直接判断，所以后面的代码i++==2不会执行
    printf("%d %d\n", i, j);
}
//打印结果
//2 2  i++ == 2执行了，i变成2，但是++j没执行，所以还是2
//1 3  ++j == 3执行了，j变成了3，但是i++没执行，所以还是1
```

**C语言没有布尔值，用0表示假，1表示真。**



#### while语句

```c
// 基本格式
while (expression){
	statement
}
```

先会判断expression的真假，如果真则执行循环体，否则不执行。

**break、continue**

break是直接跳出当前循环；continue是跳过本次循环，重新计算expression的值，再进行下一次循环。

<font style="color:red">多重循环中，break和continue只对当前的循环起作用。</font>

```c
int i = 1;
int j = 1;
while (i < 10){ // 循环体1
    printf("i=%d\n", i);
    i++;
    while (j < 10){ // 循环体2
        printf("j=%d\n", j);
        j++;
        if (j == 5){
            break; // 跳出循环体2
        }
    }
    if (i == 9){
        break; // 跳出循环体1
    }
}
```

**do while**

相当于是while循环的变体，只不过这个是至少执行一次的循环。

```c
do{
    statement;
}while(expression);
```

do while中使用break和continue也是一样的。<font style="color:red">但是有一点，调整部分需要写进while里，否则跳出do代码块后,while条件也不变，导致程序卡在那儿。</font>

```c
do {
    if (i % 2 == 0) {
        continue;
    }
    printf("i=%d\n", i);
} while (++i < 10);
```



#### for循环

```C
// for循环的基本格式
// expression1是初始化部分； expression2是条件部分； expression3是调整部分。三个表达式都可以缺省。
for (expression1; expression2; expression3){
    statement;
}
// 等价于如下while,两者其实是可以互换的。
expression1;
while (expression2){
    statement;
    expression3;
}
```



#### switch语句

```c
// 基本格式
switch (expression){
    case 1:
        // task1;
    case 2:
        // task2;
        break;
    default:
        // task3;
}
```

+ case后面的值只能是整型。
+ expression的值只表示进入到哪一个case入口，然后这个case及之后的代码都会被执行。
+ 使用break可以跳出这个语句。



#### goto标签

无条件转移语句，作用是，让程序跳转到指定的某一行去执行。

用法是：先指定一个后面带冒号的标签，然后在冒号后面写需要执行的代码，在需要跳转的地方写goto 标签。

```c
// 求和1-100
int sum = 0;
int count = 0;
loop:
if (count < 100) {
    count++;
    sum += count;
    goto loop;
}
printf("sum=%d", sum);
```

**goto语句不建议使用，因为会使结构变得杂乱。**

比如上面的例子，完全可以用循环来处理。目前有理论已经证明，所有语句可以用顺序、选择和循环这三种结构来描述，因此可以尽量少使用goto。

**应用场景：立刻跳出多层循环。**



### 操作符

#### 算术操作符

\+	\- 	*	/	% 

其中，加减乘除是适用于整型和浮点型的，%只接收两个整型操作。

<font style="color:red">**/对于除法来说，两边都是整数的话，会执行整除运算；否则执行浮点数除法。**</font>



#### 移位操作符

（箭头向左）左移 <<		（箭头向右）右移 >>

数据是以二进制形式存储的， 如00000001，左移n位表示把左边的n位去掉，把右边的数据往左挪n位，在最后面补充n个0；右移则相反。如01101101左移三位的演示图：

<img src="img\移位操作.png" alt="移位操作" style="zoom:67%;" />

移位操作符是为了提高效率而进行的。比如左移1位，在很大程度上相当于*2，用移位的方式要比乘法快得多。除此之外，还有其他的一些技巧。

**逻辑移位&算术移位**

在左移的时候，两种移位方法是一样的；

在右移的时候，逻辑移位是在左边补充0，而算术移位的左边补充0还是1，需要根据该位原先值确定，原先是1则补充1，原先是0则补充0。



#### 位操作符

<img src="img\位运算.png" alt="位运算" style="zoom:67%;" />

一般使用时也是为了提高效率。



#### 单目操作符

! 逻辑取反

~ 整型操作数求补，1变成0，0变成1

& 取地址

\* 与指针一起使用，表示指针指向的变量的值

++ -- 放在前面表示先运算后使用；放在后面表示先使用再运算



#### 关系操作符

\>	>=	<	<=	!=	==

判断结果产生的不是布尔型，而是整型，0表示假，1表示真。



#### 逻辑操作符

连接两个语句，进行判断。、

&&	||

区分 & 和 &&，一个是取地址，一个是and的含义



#### 条件操作符

expression1 ? expression2 : expression3

首先计算expression1的值，如果是真，那么这个表达式最终的值就是expression2，对于expression3就不会执行了；如果expression1的值是假，那么整个条件语句的值就是expression3，不会执行expression2。

比如： b = a > 5 ? 1 : 3;



### 表达式求值

+ 隐式类型转换  char short加减运算时需要转换成int
+ 算术转换 混合运算时会将小精度的转换成大精度的类型
+ 在计算时候需要确定运算优先级



## 指针

