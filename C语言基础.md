# C语言基础

## 数据

四种数据类型：<font style="color:red">**整型**</font>、<font style="color:red">**浮点型**</font>、<font style="color:red">**指针**</font>、<font style="color:red">**结构体**</font>

<font style="color:orange">q：为什么要设计不同的数据类型？</font>

<font style="color:green">a：我们需要数据进行存储和运算，如果各种数据都用相同的方法进行存储，很可能造成极大的空间浪费。比如说一个比较小的整数，用1个字节就能存储，你不加区分的用最大的8个字节去存储，那就浪费了7倍资源。所以对数据类型极性区分，是为了在有限资源中进行高效的存储和运算。</font>



### 基本数据类型

#### 整型

基础的有以下四种类型：

+ 字符 char
+ 短整型 short 或者写成 short int
+ 整型 int
+ 长整型 long 或者写成 long int

但是对于这四种类型，又有 singed和unsinged两种修饰，前者表示有符号可以表示负数，后者没符号表示非负数。

范围如下：

| 类型                                         | 字节            | 位数 | 范围                     |
| -------------------------------------------- | --------------- | ---- | ------------------------ |
| char                                         | 1个字节         | 8    | 0 ~ 127                  |
| singed char                                  | 1个字节         | 8    | -127 ~ 127               |
| unsinged char                                | 1个字节         | 8    | 0 ~ 255                  |
| short                                        | 2个字节         | 16   | -32767 ~ 32767           |
| unsinged short                               | 2个字节         | 16   | 0 ~ 65535                |
| int                                          | 一般4个字节     | 32   | -2147483647 ~ 2147483647 |
| unsigned int                                 | 一般4个字节     | 32   | 0 ~ 4294967295           |
| long                                         | 一般也是4个字节 | 32   | -2147483647 ~ 2147483647 |
| unsinged long                                | 一般也是4个字节 | 32   | 0 ~ 4294967295           |
| <font style="color:red">**long long**</font> | 8个字节         | 64   | -2^64+1 ~ 2^64-1         |

表示方法：

十进制的跟以前一样	24

八进制的在前面加0	024

十六进制的前面加0x	0x24

**注：表示范围跟编译器有关，int有时可以是16位，也可以是32位。但是有一个原则：short最多跟int一样长，long最少跟int一样长**

#### 浮点类型

存储小数用的。有三种类型：float、double、long double。

浮点数的存储，以32位的float为例：

任何浮点数都可以转换成  $(-1)^S * (1+\frac{M}{2^{23}}) * 2^{E-127}$形式，所以存储的时候需要这三个数字属性。

![浮点数存储](\img\浮点数存储.png)

第一段，S表示符号，正负。1个bit。0表示正数，1表示负数。

第二段，E表示指数，8个bit。之所以要-127，是因为考虑到指数可以是负数，所以取一半表示负数。

第三段，M表示小数部分，23个bit。

| 类型        | 字节 | 位数 |
| ----------- | ---- | ---- |
| float       | 4    | 32   |
| double      | 8    | 64   |
| long double | 16   | 128  |

**现在的问题就是怎么把小数部分转换成二进制的M**

整数可以写成 $a*2^0 + b*2^1 + ... c*2^n$ 这种形式（a、b、c  in {0, 1}），整数部分可以通过除以2取余数来获取二进制，

小数可以写成 $a*\frac{1}{2} + b*\frac{1}{2^2} + c*\frac{1}{2^n}$ 这种形式（a、b、c  in {0, 1}），小数部分则可以通过乘以2的形式来获取二进制。

举个例子 3.875

整数部分3=2+1，换成二进制是11

小数部分0.875=$\frac{1}{2} + \frac{1}{4} + \frac{1}{8}$ 换成二进制是0.111

所以整个数字二进制是11.111 也即是3.875=1.<font style="color:red">1111</font> * 2^1 

因此，符号S=0，指数E=1+127=128，位数M1111后面补充0

总的来说浮点数3.875在计算机内存储的形式是 **<font style="color:green">0</font><font style="color:orange">10000000</font><font style="color:red">11110000000000000000000</font>**

#### 指针

本质是一个变量，只不过这个变量是指向其他变量的内存地址。

定义格式是 datatype *name;  需要在变量前面加星号。

<font style="color:orange">q：指针是内存地址，那么为什么指针还要分这么多类型？</font>

<font style="color:green">a：为了方便通过内存地址取值。不同类型的数据有不同的存储方式，如int就是4个字节，char就是1个字节。指针表示变量的内存地址，实质上是表示这个变量地址的初始位置。假如说现在有一个指针 *p 表示地址 0X0001，我现在要读取p值地址的数据，需要读取几个字节内存？如果指针是int类型，那就读取4个字节0X0001-0X0004；如果指针是char类型，那就读取一个字节就行。</font>

赋值的时候，需要给指针赋值一个地址，否则是错误的。地址的话，在变量前面加一个&符号即可。

**定义指针时必须带*号，给指针赋值时可以不带\*号，但是赋值必须是地址**

```c
int a = 3;
int *p1; // 定义时必须*
p1 = &a; // 赋值时p1可以不带*，但是内容必须是地址
```

**指针可以修改值，也可以获取值**

```c
int a = 3;
int *p1 = &a;
printf("%d %d", a, *p1); // 打印都是3，p表示指针，*p指的是指针指向的内存地址的值
*p1 = 4;
printf("%d %d", a, *p1); // 打印的都是4
```

<font style="color:orange">q：那么指针是占几个字节呢？</font>

<font style="color:green">a：指针只是表示地址，占几个字节跟指针的类型没有关系，跟语言也没有关系，只跟系统有关。一般来说32位系统中指针占4个字节，64位系统中指针占8个字节。可以写代码测试下，定义一个*p，printf("%d", sizeof(p))，但是会发现有时候在64位系统上打印出来的也是4个字节，那是因为系统要兼容32位的程序，可以自己手动调一下设置。</font>

**指针的运算**

举个例子说明，int a = 3; int *p = &a; 假设 *p 最开始指向的是地址 0X0001，那么 p++后，它指向的内容会向后加4个字节长度，对应int的长度，因为指针每次要完整读取一个数据才行。假如是short，那么p++会加2个字节；long则加4个。以此类推。

**p *p &p的区别**

```c
int a = 3;
int *p;
p = &a; // p存储a的地址  printf(p) 打印p存储的a的地址
*p = 4; // p指向的地址的值修改为4  printf(*p) 打印p指向的地址的值
&p; // 表示指针P的地址 printf(&p) 打印p的地址
```

**字符串常量**

本质上是一个指针，指向一系列字符的初始位置，字符的结尾是NUL，也就是'\0'。即使是空字符也包含结尾符号。

下面例子中，都是字符数组，但是本质上不一样。arr 只有5个元素，而message有6个元素，最后一个是'\0'。

```c
char[] arr = {'h', 'e', 'l', 'l', 'o'};
char* message = "hello";
```



### 其他数据

#### **字面量**

固定值的一种表示方法，就是已经确定的值。

+ 可以是整型  22， 23L
+ 可以是浮点型 22.2，33.3F
+ 可以是字符型 'a'、'b'
+ 可以是字符串型 "Hello world"

#### **枚举类型**

先举个例子

```c
// 定义一个枚举类型 Day
enum Day{
    MON = 1,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
};
// 声明一个枚举类型Day的变量
enum Day day;
// 定义这个变量的数值
day = WED;
// 打印测试 结果打印3
printf("%d", day); 
```

枚举类型本质上与 define是一样的，都是用一些有意义的字符串表示某些数字。但是如果全部用define表示，那么会显得宏定义比较杂乱。

<font style="color:red">**数值关系：**</font>如果最开始的枚举数没有给定一个值，那么默认从0开始；后面一个数的值是前面一个数+1。



### 声明

#### **变量声明**

int a; 	int a = 5;

#### **数组声明**

int values[20];	int values[5] = {1, 2, 3, 4, 5};	int values[5] = {1, 2, 3};

最后一个，元素不足5个，补充0。

#### **指针声明**

int *a;	char *message = "hello";

<font style="color:red">int *a, b, c； 其中只有a是指针，b、c是int类型数据变量。</font>

#### **隐式声明**<font style="color:red">（不推荐）</font>

变量不声明具体的类型，默认是整型。

函数不声明具体的返回类型，默认是void。

#### **typedef、define用法**

共同点：他们都是一种宏替代的方法，都是为了程序修改起来更方便而存在的。都是用新的名称替代原来的函数或者常量。

不同点：typedef可以操作指针，define则不行。并且define是在编译期间就进行替换，不会有类型的检查；typedef是在代码运行期间进行替换的，如果出问题会报错。

应用场景：在简单的常量替换和函数操作时用define，在新的类型替换时用typedef。

#### **const 关键词**

const修饰不可修改的变量。它的本质还是一个变量。

<font style="color:red">const最大的问题是与指针等联合使用的区分</font>

方法：谁离const近，谁就不能被修改。

```C
// 下面两种写法是等价的，因为这个不是指针变量，只表示数值。
const int a = 5;
int const a = 5;
// 当涉及指针时候需要注意
int *p; // 表示一个普通的指向整型的指针。
int* const p; // 表示一个指向整型的指针，不可以修改指针的值，但是能修改指针指向的值。
int const *p; // 表示一个指向整型的指针，可以修改指针的值，但是不能修改指针指向的值。
const int* p; // 表示一个指向整型的指针，可以修改指针的值，但是不能修改指针指向的值。
int const * const p; // 表示一个指向整型的指针，不可以修改指针的值，不能修改指针指向的值。
```



### 数据类型转换

类型转换，**只是临时性的**，数据本身的存储方式并没有改变。只是使用的时候，显示方式改变了。

#### 自动类型转换

程序认为数据类型需要转换，偷偷地进行了，不需要程序员干预。

这种情况一般发生在多种数据类型在混合计算中，或者赋值的情况当中。

自动转换的规则：

![自动类型转换](\img\自动类型转换.png)

+ 一般而言，当精度小的和精度大的混合运算时，需全部转换成精度大的进行计算。如int和long计算，需要转换成long。
+ 对于所有的浮点数，都转换成double计算。
+ 对于short和char，都需要先转换成int再计算。

#### 强制类型转换

（新类型名称）表达式;



### 作用域

作用域表示变量或者表达式的有效范围。**本质是变量和表达式在内存中存在的生命周期。**

#### <font style="color:red">代码块作用域（局部变量）</font>

{}中间的代码，并且{}可以嵌套。在{}中定义的变量，只能在当前{}中有效。

嵌套的{}内层和外层有区别，外层的变量可以在内层用，内层的变量不能在外层中使用。同时如果内层外层都定义了一个相同名称的变量，在使用时，操作代码在哪一层就使用哪一层的变量数值。

#### <font style="color:red">文件作用域（全局变量）</font>

这个文件作用域中的文件，只的是.c文件。也就是在这个.c文件中都有用。

在代码块之外声明的变量都具有文件作用域。

#### 原型作用域（函数原型）

这个是针对函数原型而言的。在代码使用上基本没什么需要关注的。

函数原型实际上是函数声明的一种。比如说，main函数里需要调用func1函数，但是func1函数是写在main函数后面的，程序在main中调用func1会发生错误，那么解决这个问题有两种方法，一种是将func1函数写在main前面，一种则是在.c文件的顶部区域对函数进行声明，如下：

```c
void func(int a, int b); // 函数声明
void func2(int); // 函数原型可以不带参数

int main(){
    return 0;
}

void func1(int a, int h){} // 函数定义和函数声明里面的形参可以不一致

void func2(int a){}
```



### 链接属性

不少书本和博客关于这方面的内容，一上来就是外部链接、内部链接和none这些东西，并没有讲外部和内部都有哪些作用，虽然内容简单，但是初看起来还是让人一头雾水。C项目是以工程为基准的，一个C项目里面可能有好多个.c文件，如a.c文件，b.c文件等，如果a.c文件中的变量或者函数能在b.c文件中直接使用，那么这些变量或者函数是外部链接；否则是内部链接或者是none。

+ 默认情况下全局变量是external，代码块内的变量默认是none。
+ static修饰则是internal。extern修饰则是external。

<font style="color:orange">q：为什么需要全局变量？</font>

<font style="color:green">a：这个涉及到C项目的编译内容。C项目包含多个.c文件，首先需要将.c文件进行预处理，然后编译成汇编的.s文件，然后将.s文件转换成二进制的机器语言.o文件，一个.c文件对应一个.o文件。然后需要将多个.o文件和依赖库文件进行链接，最终生成.exe文件。那么在链接过程中，多个.c文件中可能有一些变量或者函数是重名了的，那么为了进行区分，a.c文件中的int h，与b.c文件中的int h，是同一个变量还是只在各自的文件中起作用，这个需要界定清楚，所以需要给定一个链接属性。同时可以看出，函数内的局部变量和形参，都是另外开辟一个栈内存存储变量的，不存在混用的情景，因此这些变量没有链接属性。</font>



### 数据的存储

数据都是以二进制形式存放在计算机中的。

#### 原码、反码和补码

**有符号** 最前一位，如果是0表示正数，如果是1表示负数。

**无符号** 没有符号位，全部是非负数。

相同位数的有符号和无符号数的表示的范围不一样。

当有符号和无符号的数据在同一个表达式中，**都会先转换成无符号数。**

**原码** 数字的原本二进制表示方法

比如1，00000001；比如-1，10000001。

**反码** 正数的反码就是原码保持不变，负数的反码是原码的符号位保持不变，其他位都取反。

比如 1，原码是 00000001，是正数反码跟原码一样，所以反码也是 00000001。

比如-2，原码是 10000010，是负数所以需要进行处理，最终反码是 11111101。

<font style="color:red">**反码的存在是为了解决计算机中减法问题**</font>

在计算机最底层，只支持加法运算，那么减法怎么处理？加上一个负数就算是减法。但是对负数的原码做加法运算，会出现问题，导致结果不对，所以设置一个反码来解决减法问题。

两个正数相加，没有问题；两个负数相加，可以看作是两个正数相加，然后把结果的符号位强制换成1就行。

关键的问题是正数和负数相加。比如1+(-2)：

（1反码）00000001 + （-2反码）11111101 = （结果反码）11111110

把结果的反码再取一下反码就得到结果 100000001，也就是-1。能成功解决问题。

可以类比时针向前转一圈跟向后转一圈效果一样，反码就相当于转了一圈。

**补码（原码和补码相加刚好能溢出）**

<font style="color:red">解决0和-0的问题，同时补码更有利于计算</font>

正数和0的补码和原码相同。负数的补码是反码+1。

比如 1，原码是 00000001，是正数反码跟原码一样，所以反码也是 00000001，补码也是 00000001。

比如-1，原码是 10000001，是负数所以需要进行处理，最终反码是 11111110，在此基础上补码是 11111111。

所以按照补码来讲，1-1=1+(-1)：

（1补码）00000001 + （-1补码）11111111 = （结果补码溢出）00000000

结果补码求原码，0的补码是本身，得到 00000000，结果是0。

**总结**

+ 原码是初始的二进制
+ 反码是解决减法问题的
+ 补码是解决0和-0问题的，目前计算机上数据都是用补码进行存储的。

